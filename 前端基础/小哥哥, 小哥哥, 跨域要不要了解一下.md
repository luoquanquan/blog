> 一直打算纯前端做一个接口测试工具, 直到遇到
> ![2018-12-05-14-13-31](http://img.blog.niubishanshan.top/2018-12-05-14-13-31.png)
> 这个报错, 触碰了知识盲区了, 怎么办???
> ![2018-12-05-14-14-58](http://img.blog.niubishanshan.top/2018-12-05-14-14-58.png)
> 还好, 有谷哥和度娘. 原来是[跨域了](https://baike.baidu.com/item/AJAX%20%E8%B7%A8%E5%9F%9F%E8%AE%BF%E9%97%AE/15633363)
> 随手整理了一下常用的跨域方式处理方案, 这里马上分享给大家 😋

ps: 本文中涉及部分后端内容. 为了保证前后端编码的一致性, 后端统一使用原生 nodejs 来搞.

## 准备工作

为了托管我们的静态页面, 我们需要一个可以提供服务器环境的插件, 这里推荐 `live-server`, 通过命令 `npm i -g live-server` 即可. 该插件支持内容热更新. 那用户体验简直飞起. 一键启动, 只需要在需要托管的目录执行 `live-server .` 即可.
![9150e4e5ly1fvmnifqdj2g207i07iaa4](http://img.blog.niubishanshan.top/9150e4e5ly1fvmnifqdj2g207i07iaa4.gif)

ps: `live-server` 依赖 nodejs, 没有安装的小伙伴, 请参照[这篇文章](https://juejin.im/post/5bfd43986fb9a049ed308f1a)安装 nodejs.

## AJAX 访问接口跨域解决方案

首先, 更正几个常见的错误:
1. 跨域是浏览器的行为, 和 js 关系不大.
2. 所谓跨域是指请求发起方页面所在的 url 与访问的 api 存在协议, 域名, 端口中任意一个不同即视为跨域. 并不单单是指域名.
3. 跨域这个东西, 日常工作中并不是很常用. 你想, 谁会闲的没事儿干总是请求人家别人的 api 去.

### jsonp

> 可能有小伙伴会说. 圈圈, 你扯淡, 既然浏览器有跨域限制. 为什么我司项目从 [bootcdn](https://www.bootcdn.cn/), 引入的 jquery 依然跑在信息高速路上, 没有任何低头的意思?

hhh, 😄. 这个质疑提的好. 浏览器同源策略禁止的是 ajax 请求. 然鹅, jquery 是一个 js 文件. 不受该策略的限制. 我尼玛, 那到底是啥限制啥不限制嘛??
![2018-12-05-16-05-22](http://img.blog.niubishanshan.top/2018-12-05-16-05-22.png)

根据 [MDN](https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy) (自备梯子), 对于浏览器的同源策略的解释, 不受限制的外域资源加载情况有以下几种:
- script
- link
- img
- video
- object embed applet
- font-face 有的浏览器允许, 有的禁止
- frame

那么问题来了, 挖掘机学校..., 不好意思走错片场了. 既然有这么多方式可以绕过浏览器同源策略的限制. 那么, 是不是我们可以做一点事情呢 ^_^

是的 😄.

接下来, 我们使用第一个特例 `script` 一步一步实现跨域访问 (jsonp).

- 首先, 创建本次文章的项目目录
![2018-12-05-17-14-53](http://img.blog.niubishanshan.top/2018-12-05-17-14-53.png)
目录中, be 代表是后端项目, fe 代表前端项目. jsonp 目录说明我们是用 jsonp 的方式实现跨域.
- 在项目根目录下执行 `live-server ./fe/jsonp/` 启动前端 web 容器
- 编辑 `./fe/jsonp/` 目录下的 index.html 文件. 代码如下:

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>jsonp 实现跨域</title>
</head>
<body>
    <h3>jsonp 实现跨域</h3>
</body>
</html>
```

- 浏览器访问 [localhost:8080](http://localhost:8080/)浏览器如下图说明前端 web 容器部署成功.
![2018-12-05-17-22-21](http://img.blog.niubishanshan.top/2018-12-05-17-22-21.png)

- 编写后端代码, 编写 `be/jsonp/index.js` 文件, 文件内容如下

```js
var http = require('http');
var PORT = 8888

// 创建一个 http 服务
var server = http.createServer(function(request, response) {
    response.end('hello world')
})

// 启动服务, 监听端口
server.listen(PORT, function() {
    console.log('服务启动成功, 正在监听: ', PORT)
})
```

- 编写完成后命令行执行 `node ./be/jsonp/index.js`
命令行中出现![2018-12-05-17-57-06](http://img.blog.niubishanshan.top/2018-12-05-17-57-06.png)说明后端程序启动成功.此时可以通过浏览器访问 [localhost:8888](http://localhost:8888/)获得 hello world
![2018-12-05-19-15-36](http://img.blog.niubishanshan.top/2018-12-05-19-15-36.png)

- 下来, 我们在前端的 `index.html` 中尝试通过 ajax 请求 `http://localhost:8888/` 来获取返回数据, 添加如下代码, 添加以后[代码](https://github.com/luoquanquan/cross-domain/commit/cce37cc50db74d0584f55da393d948c1dcfa7696)

```html
<script>
    var xhr = new XMLHttpRequest()
    xhr.open('GET', 'http://localhost:8888/')
    xhr.send()
</script>
```

回到浏览器, 查看页面控制台, 熟悉的错误出现了. Access to XMLHttpRequest at `http://localhost:8888/` from origin `http://127.0.0.1:8080` has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource. 这个错误说明了, 我们是不能通过 ajax 的方式从 `http://127.0.0.1:8080` 访问 `http://localhost:8888/` 的.

既然不能通过 ajax 实现跨域的访问, 同时 mdn 又说 script 标签不受同源策略的限制. 那么, 我们尝试一下用 script 标签引入 `http://localhost:8888/` 试试?
![2018-12-05-19-29-19](http://img.blog.niubishanshan.top/2018-12-05-19-29-19.png)
此时的[代码](https://github.com/luoquanquan/cross-domain/commit/d7ae69f656b1476a25057614264c411f7de13da4), 网络请求没有问题. 知识报了 js 文件不合法的问题. 如果我们把接口返回的数据调整为规范的 js 是不是, 嗯哼???

- 干起, 修改后端代码, 返回的内容由 `hello world` 改为 `console.log('hello world')`, 修改后的[代码](https://github.com/luoquanquan/cross-domain/commit/bb5b1d2c6a1f3756c4fc7d5dda04e9bc6b30310e)

不得了, 不得了, 返回的结果不紧没有报错, 甚至可以执行.
![2018-12-05-20-15-32](http://img.blog.niubishanshan.top/2018-12-05-20-15-32.png)

试想一下, 如果我们通过 js 文件里定义一个变量用于存放后端返回给前端的数据, 前端插入一个 script 标签, 把后端返回的变量定义执行一把. 那样定义的变量岂不是就可以在全局可以获取到了. 赶紧试一把 😄

首先修改后端代码, 只需要调整一行.

```js
response.end("var aaaa = {name: 'quanquan', friend: 'guiling'}");
```

其次调整前端代码

```html
<script>
    // 第一次因为还没有引入外部 js 所以打印 undefined
    console.log(window.aaaa)
    // 1 秒后, 外部 js 加载完成, 能打印出后端返回的变量定义
    setTimeout(() => {console.log(window.aaaa)}, 1e3)
</script>
<script src="http://localhost:8888/"></script>
```

当前[代码](https://github.com/luoquanquan/cross-domain/commit/5bdc0dd023f4676a8d6eebb87af73e087661d830)通过这种方式, 我们能够成功的获取到后端返回的数据. 但是, 接口这个东西有时候返回的快, 有时候返回的慢. 写个定时器轮询? 有点不够 666, 肿么办?
![2018-12-05-21-15-37](http://img.blog.niubishanshan.top/2018-12-05-21-15-37.png)

========================  思考 5 分钟  ========================
![2018-12-05-21-18-13](http://img.blog.niubishanshan.top/2018-12-05-21-18-13.png)
========================   5 分钟已过  ========================

既然, 写在 script 标签上的内容是可以直接执行的. 那么, 如果我们把变量的定义改写成一个函数的执行可不可以呢 ^_^, 试试?

后端(修改完后端代码以后切记重启服务哈 ^_^)

```js
response.end("aaaa({name: 'quanquan', friend: 'guiling'})");
```

前端

```html
<script>
    // 由于后端返回的内容即将调用函数 aaaa, 那我们就预先定义一个呗, 这东西就叫回调函数
    function aaaa(param) {
        console.log('后端返回的参数是: ', param)
    }
</script>
<script src="http://localhost:8888/"></script>
```

结果
![2018-12-05-21-30-30](http://img.blog.niubishanshan.top/2018-12-05-21-30-30.png)

此时[代码](https://github.com/luoquanquan/cross-domain/commit/a2e0ba9ca2edcabf03ca549fd018d85c96fa0c64), 目前为止, 我们已经彻底解决了跨域的问题. 很靠谱有木有? 答案是木有. 这个玩意只是说明了 jsonp 的原理, 并没有实用性. 下一步, 我们做一些封装. 让我们的代码更健壮 💪🏻

















